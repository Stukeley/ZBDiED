install.packages("rattle")
install.packages("rattle")
# Ćw 1
library(rattle)
rattle()
install.packages("RGtk2")
install.packages("RGtk2")
install.packages("rattle")
library(rattle)
install.packages(rattle)
install.packages("rattle")
rattle()
remotes::install_github("cran/rattle")
library(remotes)
install.packages("rattle", repos="https://rattle.togaware.com", type="source")
install.packages("https://access.togaware.com/RGtk2_2.20.36.2.tgz", repos=NULL, type="binary")
install.packages("rattle")
library(rattle)
rattle()
install.packages("RGtk2")
install.packages("https://cran.r-project.org/src/contrib/Archive/RGtk2/RGtk2_2.20.36.tar.gz")
install.packages("RGtk2", depen=T, type="source")
install.packages("RGtk2")
install.packages("RGtk2", depen=T, type="source")
install.packages("https://access.togaware.com/RGtk2_2.20.36.2.tgz", repos=NULL, type="binary")
# Rattle install
system('brew install gtk+')
local({
if (Sys.info()[['sysname']] != 'Darwin') return()
.Platform$pkgType = 'mac.binary.el-capitan'
unlockBinding('.Platform', baseenv())
assign('.Platform', .Platform, 'package:base')
lockBinding('.Platform', baseenv())
options(
pkgType = 'both', install.packages.compile.from.source = 'always',
repos = 'https://macos.rbind.io'
)
})
install.packages(c('RGtk2', 'cairoDevice', 'rattle'))
install.packages(c("RGtk2", "cairoDevice", "rattle"))
library(rattle)
rattle()
install.packages("RGtk2")
install.packages("xfun")
system2('brew', c('install', xfun:::brew_dep('RGtk2')))
xfun:::brew_dep("RGtk2")
R
version()
R.version()
R.version
install.packages("RGtk2")
install.packages("rattle")
install.packages("rattle")
library(rattle)
install.packages("https://access.togaware.com/RGtk2_2.20.36.2.tgz", repos=NULL, type="binary")
install.packages("rattle")
library(rattle)
rattle()
install.packages("RGtk2")
install.packages("https://cran.r-project.org/src/contrib/Archive/RGtk2/RGtk2_2.20.30.tar.gz", repos=NULL)
rattle()
install.packages("https://cran.r-project.org/src/contrib/Archive/RGtk2/RGtk2_2.20.30.tar.gz", repos=NULL)
install.packages("https://cran.r-project.org/src/contrib/Archive/RGtk2/RGtk2_2.20.30.tar.gz", repos=NULL)
install.packages("gtk")
install.packages("https://cran.r-project.org/src/contrib/Archive/RGtk2/RGtk2_2.20.36.3.tar.gz", repos=NULL, type="sources")
install.packages("https://cran.r-project.org/src/contrib/Archive/RGtk2/RGtk2_2.20.36.3.tar.gz", repos=NULL, type="sources", dependencies = TRUE)
.libPaths()
library(RGtk2)
library(RGtk2)
install.packages("rattle")
library(rattle)
rattle()
ds -< with (crsSdataset[crs§train, 1, rbind (data. frame (dat=Humidity3pm, grp="A11"), data. frame (dat=Humidity3pm[RainTomorrow=="No"],grp="No") ,
data.frame(dat=Humidity3pm[RainTomorrow=="Yes"],grp="Yes")))
# ZBDiED, Lab 6, Rafał Klinowski
library(class)
library(gmodels)
# Algorytm kNN dla danych dotyczących raka
wbcd <- read.csv("wisc_bc_data.csv", stringsAsFactors = FALSE)
setwd(".")
# Algorytm kNN dla danych dotyczących raka
wbcd <- read.csv("wisc_bc_data.csv", stringsAsFactors = FALSE)
setwd("/Users/stukeleyak/Desktop/Studia/Studia magisterskie sem 2/ZBDIED/Lab6")
# Algorytm kNN dla danych dotyczących raka
wbcd <- read.csv("wisc_bc_data.csv", stringsAsFactors = FALSE)
str(wbcd)
# Usunięcie pierwszej kolumny
wbcd <- wbcd[-1]
table(wbcd$diagnosis)
# Zmiana oznaczeń klas
wbcd$diagnosis<- factor(wbcd$diagnosis, levels = c("B", "M"),labels = c("łagodny", "złośliwy"))
round(prop.table(table(wbcd$diagnosis)) * 100, digits = 1)
# Wartości pierwszych trzech zmiennych
summary(wbcd[c("radius_mean", "area_mean", "smoothness_mean")])
# Utworzenie funkcji do normalizacji
normalize <- function(x) {return ((x - min(x)) / (max(x) - min(x)))}
# Przetestowanie funkcji
normalize(c(1,2,3,4,5,6))
# Normalizacja zbioru
wbcd_n <- as.data.frame(lapply(wbcd[2:31], normalize))
str(wbcd_n)
summary(wbcd_n[c("radius_mean", "area_mean", "smoothness_mean")])
# Normalizacja zbioru
wbcd_n <- as.data.frame(lapply(wbcd[2:31], normalize))
summary(wbcd_n[c("radius_mean", "area_mean", "smoothness_mean")])
# Zbudowanie zbioru treningowego i testowego
wbcd_train <- wbcd_n[1:469, ]
wbcd_test <- wbcd_n[470:569, ]
wbcd_train_diag <- wbcd[1:469, 1]
wbcd_test_diag <- wbcd[470:569, 1]
# Utworzenie klasyfikatora kNN
p<-knn(train,test,class,k)
# Utworzenie klasyfikatora kNN
wbcd_test_pred <- knn(train = wbcd_train, test = wbcd_test,cl = wbcd_train_diag, k = 21)
CrossTable(x = wbcd_test_diag, y = wbcd_test_pred,prop.chisq=FALSE)
# Powtórzenie powyższych kroków po standaryzacji
wbcd_z <- as.data.frame(scale(wbcd[-1]))
summary(wbcd_z)
wbcd_train_z <- wbcd_z[1:469, ]
wbcd_test_z <- wbcd_z[470:569, ]
wbcd_test_pred_z <- knn(train = wbcd_train_z, test = wbcd_test_z,cl = wbcd_train_diag, k = 3)
CrossTable(x = wbcd_test_diag, y = wbcd_test_pred_z,prop.chisq=FALSE)
# Powtórzenie dla k=15, normalizacja
wbcd_train <- wbcd_n[1:469, ]
wbcd_test <- wbcd_n[470:569, ]
wbcd_test_pred <- knn(train = wbcd_train, test = wbcd_test,cl = wbcd_train_diag, k = 15)
CrossTable(x = wbcd_test_diag, y = wbcd_test_pred,prop.chisq=FALSE)
# Powtórzenie dla k=15, standaryzacja
wbcd_train_z <- wbcd_z[1:469, ]
wbcd_test_z <- wbcd_z[470:569, ]
wbcd_test_pred_z <- knn(train = wbcd_train_z, test = wbcd_test_z,cl = wbcd_train_diag, k = 15)
CrossTable(x = wbcd_test_diag, y = wbcd_test_pred_z,prop.chisq=FALSE)
# Powtórzenie dla k=5
wbcd_train <- wbcd_n[1:469, ]
wbcd_test <- wbcd_n[470:569, ]
wbcd_test_pred <- knn(train = wbcd_train, test = wbcd_test,cl = wbcd_train_diag, k = 5)
CrossTable(x = wbcd_test_diag, y = wbcd_test_pred,prop.chisq=FALSE)
# Powtórzenie dla k=3
wbcd_train <- wbcd_n[1:469, ]
wbcd_test <- wbcd_n[470:569, ]
wbcd_test_pred <- knn(train = wbcd_train, test = wbcd_test,cl = wbcd_train_diag, k = 3)
CrossTable(x = wbcd_test_diag, y = wbcd_test_pred,prop.chisq=FALSE)
# Algorytm k-Means dla danych dotyczących profili społecznościowych
ds<- read.table(header = TRUE,"snsdata.csv",sep = ",")
str(ds)
# Eksploracja danych
# Histogram dla zmiennej gender
ds$gender<-ifelse(is.na(ds$gender), 3, ds$gender)
# Algorytm k-Means dla danych dotyczących profili społecznościowych
ds<- read.table(header = TRUE,"snsdata.csv",sep = ",")
str(ds)
# Eksploracja danych
# Histogram dla zmiennej gender
hist(ds$gender)
ds$gender
# Eksploracja danych
# Histogram dla zmiennej gender
genders <- ifelse(ds$gender=="F", 1, 2)
hist(genders)
# Eksploracja danych
# Histogram dla zmiennej gender
genders <- table(ds$gender)
hist(genders)
genders
barplot(genders)
e
# Uzupełnienie brakujących wartości
ds$gender<-ifelse(is.na(ds$gender), 3, ds$gender)
# Age
summary(ds$age)
ds$age <- ifelse(ds$age >= 13 & ds$age < 20, ds$age, NA)
summary(ds$age)
# Zamiana brakujących danych na średnie
aggregate(data = ds, age ~ gradyear, mean, na.rm = TRUE)
ave_age <- ave(ds$age, ds$gradyear, FUN =function(x) mean(x, na.rm = TRUE))
tail(ave_age, n=200)
ds$age <- ifelse(is.na(ds$age), ave_age, ds$age)
summary(ds$age)
# Normalizacja danych
interests <- ds[5:40]
interests_z <- as.data.frame(lapply(interests, scale))
teen_clusters <- kmeans(interests_z, 5)
teen_clusters$size
summary(interests_z)
summary(ds)
# Usunięcie brakujących danych dotyczących zainteresowań
drop_na(ds)
# Usunięcie brakujących danych dotyczących zainteresowań
ds <- na.omit(ds)
# Normalizacja danych
interests <- ds[5:40]
interests_z <- as.data.frame(lapply(interests, scale))
summary(interests_z)
teen_clusters <- kmeans(interests_z, 5)
teen_clusters$size
teen_clusters$centers
summary9ds
summary(ds)
summary(ds$gradyear)
values(ds$gradyear)
table(ds$gradyear)
# k-Means dla k=4
teen_clusters <- kmeans(interests_z, 4)
teen_clusters$size
teen_clusters$centers
# k-Means dla k=12
teen_clusters <- kmeans(interests_z, 12)
teen_clusters$size
teen_clusters$centers
# k-Means dla k=2
teen_clusters <- kmeans(interests_z, 2)
teen_clusters$size
teen_clusters$centers
# Analiza wartości k
library(ggplot)
install.packages(ggplot)
install.packages("ggplot")
install.packages("ggplot2")
# Analiza wartości k
library(ggplot)
# Analiza wartości k
library(ggplot2)
library(stats)
ssd <- numeric(10)  # Zakładamy, że sprawdzamy od 1 do 10 klastrów
for (k in 1:10) {
kmeans_model <- kmeans(dane, centers = k)
ssd[k] <- kmeans_model$tot.withinss
}
elbow_plot <- ggplot() +
geom_line(aes(x = 1:10, y = ssd), color = "blue") +
geom_point(aes(x = which.min(ssd), y = min(ssd)), color = "red", size = 3) +
labs(title = "Elbow Method",
x = "Number of Clusters (k)",
y = "Sum of Squared Distances (SSD)") +
theme_minimal()
print(elbow_plot)
# Analiza wartości k
library(ggplot2)
library(stats)
ssd <- numeric(10)  # Zakładamy, że sprawdzamy od 1 do 10 klastrów
for (k in 1:10) {
kmeans_model <- kmeans(interests_z, centers = k)
ssd[k] <- kmeans_model$tot.withinss
}
elbow_plot <- ggplot() +
geom_line(aes(x = 1:10, y = ssd), color = "blue") +
geom_point(aes(x = which.min(ssd), y = min(ssd)), color = "red", size = 3) +
labs(title = "Elbow Method",
x = "Number of Clusters (k)",
y = "Sum of Squared Distances (SSD)") +
theme_minimal()
print(elbow_plot)
library(stats)
ssd <- numeric(15)  # Zakładamy, że sprawdzamy od 1 do 10 klastrów
for (k in 1:15) {
kmeans_model <- kmeans(interests_z, centers = k)
ssd[k] <- kmeans_model$tot.withinss
}
elbow_plot <- ggplot() +
geom_line(aes(x = 1:15, y = ssd), color = "blue") +
geom_point(aes(x = which.min(ssd), y = min(ssd)), color = "red", size = 3) +
labs(title = "Elbow Method",
x = "Number of Clusters (k)",
y = "Sum of Squared Distances (SSD)") +
theme_minimal()
print(elbow_plot)
ssd <- numeric(20)  # Zakładamy, że sprawdzamy od 1 do 10 klastrów
for (k in 1:20) {
kmeans_model <- kmeans(interests_z, centers = k)
ssd[k] <- kmeans_model$tot.withinss
}
elbow_plot <- ggplot() +
geom_line(aes(x = 1:20, y = ssd), color = "blue") +
geom_point(aes(x = which.min(ssd), y = min(ssd)), color = "red", size = 3) +
labs(title = "Elbow Method",
x = "Number of Clusters (k)",
y = "Sum of Squared Distances (SSD)") +
theme_minimal()
print(elbow_plot)
summary(ds)
